<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tracking</title>
    <style>canvas { rotate: 180deg; }

      .big{
          width: 200px;
          font-size: 30px;
          height: 100px;
      }

      .content {
        width: 50%;
        display: flex;
        flex-direction: row;
        justify-content: center;
        align-items: center;
      }

      .container {
        display: flex;
      }

      #canvas{
        position: relative;
      }

      .secondary-canvas {
        position: absolute;
        top: 1px;
        left: 1px;
        background-color: transparent;
      }

      .table-cont{
        width: 100%;
        overflow: auto;
      }

      .content {
        flex: 1; /* Fai espandere il div content per riempire lo spazio rimanente */
        padding: 10px; /* Aggiungi spazio interno al div content */
        display: flex;
        flex-direction: column;
        justify-content: center;
      }

      .big {
        margin-bottom: 10px; /* Aggiungi spazio tra gli elementi con classe "big" */
      }

      #percent {
        margin-left: 5px; /* Aggiungi spazio tra l'elemento con id "percent" e il precedente */
      }

      #player {
        margin-top: 10px; /* Aggiungi spazio sopra al selettore "player" */
      }

      #time,
      #date {
        margin-top: 10px; /* Aggiungi spazio sopra ai campi di input "time" e "date" */
      }
    </style>
</head>
<body>

    <div class="container">
      <canvas id="canvas" style="border: 1px solid red;"></canvas>
      <canvas class="secondary-canvas" id="player1-canvas"></canvas>
      <canvas class="secondary-canvas" id="player2-canvas"></canvas>
      <canvas class="secondary-canvas" id="objects-canvas"></canvas>
      <canvas class="secondary-canvas" id="circles-canvas" style="z-index: 99;"></canvas>
      <div class="content">
        <span class="big">Raggio</span>
        <input type="range" id="radius" min="0" max="800" value="200" class="big" onchange="drawFacade()">
        <span class="big">Percentuale punti nell'area: </span><span class="big" id="percent"></span>
        <!-- Make a selector -->
        <select name="player" class="big" id="player">
          <option value="player1">Player 1</option>
          <option value="player2">Player 2</option>
          <option value="everyone">Tutti</option>
        </select>
        <span class="big">Tempo</span>
        <input type="time" id="time" class="big">
        <input type="date" id="date" class="big">
        <button onclick="drawFacadeWithFilters()">Filtra</button>
        <!--TODO: Tabell per le posizioni-->
      </div>
    </div>

    <script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/core-js/2.1.4/core.min.js"></script>
    <script crossorigin="anonymous" src="//unpkg.com/@feathersjs/client@^4.5.0/dist/feathers.js"></script>
    <script crossorigin="anonymous" src="//unpkg.com/socket.io-client@^2.3.0/dist/socket.io.js"></script>

    <script>
        //TODO: Trasportare questa pagina nella pagina persona: Si potrà vedere una comparativa tra utenti o visualizzazione di un singolo utente
        //visualizzare con quali oggetti 3d il giocatore ha interagito e dare delle label a questi oggetti con timestamp e altri metadati se disponibili, inoltre si potrà vedere il percorso che il giocatore ha fatto
        //aggiungere la possibilità di scegliere un oggetto 3d, il raggio e quindi vedere i punti della trayettoria che sono dentro il cerchio, dunque avere un notifier di prossimità per l'oggetto 3d selezionato rispetto al player.

        // Socket.io is exposed as the `io` global.
        var socket = io('http://localhost:3030');
        // @feathersjs/client is exposed as the `feathers` global.
        var app = feathers();
        var _positions = new Array();
        var _positions_2 = new Array(); //array di posizioni del secondo player

        //crea una canvas con un background di una immagine di cui conosco il path
        var canvas = document.getElementById("canvas"),
        ctx = canvas.getContext("2d");

        var p1canvas = document.getElementById("player1-canvas"),
        p1_ctx = p1canvas.getContext("2d");

        var p2canvas = document.getElementById("player2-canvas"),
        p2_ctx = p2canvas.getContext("2d");

        var objs_canvas = document.getElementById("objects-canvas"),
        objs_ctx = objs_canvas.getContext("2d");

        var circles_canvas = document.getElementById("circles-canvas"),
        circles_ctx = circles_canvas.getContext("2d");

        //seleziona il player
        document.getElementById("player").addEventListener("change", function(){
          console.log("changed");
          let player = document.getElementById("player").value;
          if(player == "player1"){
            //nascondi la canvas del secondo player
            document.getElementById("player2-canvas").setAttribute("hidden", "hidden")
            //rendi visibile la canvas del primo player
            document.getElementById("player1-canvas").removeAttribute("hidden")
            console.log("p1");

          }else if(player == "player2"){
            //nascondi la canvas del primo player
            document.getElementById("player1-canvas").setAttribute("hidden", "hidden")
            //rendi visibile la canvas del secondo player
            document.getElementById("player2-canvas").removeAttribute("hidden")
            console.log("p2");

          }else{
            //rendi visibile la canvas del primo player
            document.getElementById("player1-canvas").removeAttribute("hidden")
            //rendi visibile la canvas del secondo player
            document.getElementById("player2-canvas").removeAttribute("hidden")
            console.log("every1");
          }
        });

        var center = {x: 0, y: 0};

        app.configure(feathers.socketio(socket));

        socket.on('connect', () => console.log('Connected to server.'));

        socket.on("test-ngsild created", async (data) => {
            console.log("POSIZIONE ", data);
            try{
              if(data.type != undefined) {
                return;
              }
            }catch(e){
              return;
            }

            let pos = data;
            pos.position[0] = (pos.position[0] *70 )+ 700
            pos.position[2] = (pos.position[2] *70 )+ 700
            console.log(pos)
            if(pos.id == "minerva:2:12396:ABCD:player"){
              _positions.push(pos);
              //add a row to the pos-table
              console.log("ARRAY POS", _positions);
              await draw(p1_ctx, _positions, null,  "red", "purple");
            }else{
              _positions_2.push(pos);
              await draw(p2_ctx, _positions_2, null, "blue", "yellow");
            }
        });

        socket.on("test-ngsild obj-pos", async (data) => {
            //disegna un cerchio colore verde di raggio 50 usando data.position[0] e data.position[2]
            console.log("OBJ VERDE", data);
            await drawGreenCircle(data.position);
        });

        function pushPos(pos){
          _positions.push(pos);
        }

        function getLength(){
          return _positions.length;
        }

        socket.emit('find', 'position', {}, (error, data) => {
          console.log('Found all messages', data);
        });
        // feathers.errors is an object with all of the custom error types.

        canvas.width = 1500;
        canvas.height = 1500;

        center.x = canvas.width/2;
        center.y = canvas.height/2;

        var background = new Image();
        background.src = "map.png";

        // Make sure the image is loaded first otherwise nothing will draw.
        background.onload = async function(){
            //setta il background della canvas della dimensione della canvas
            const first = await fetch('https://broker.minerva.sferainnovazione.com/ngsi-ld/v1/entities/urn:ngsi-ld:Scene:002');
            const data2 = await first.json();
            console.log(data2);

            //setta width e height della canvas usando i dati del json moltiplicati per 70
            canvas.width = data2.width.value * 70;
            canvas.height = data2.length.value * 70;

            p1canvas.width = data2.width.value * 70;
            p1canvas.height = data2.length.value * 70;

            p2canvas.width = data2.width.value * 70;
            p2canvas.height = data2.length.value * 70;

            objs_canvas.width = data2.width.value * 70;
            objs_canvas.height = data2.length.value * 70;

            circles_canvas.width = data2.width.value * 70;
            circles_canvas.height = data2.length.value * 70;

            ctx.drawImage(background,0,0, canvas.width, canvas.height);

            //disegna un path con le coordinate che gli passo
            //prendi le coordinate dal json
            //nell'array position itera sugli oggetti e prendi l'array "value" questo contiene le coordinate
            //pusha le coordinate nell'array coordinates
            for (let i = 0; i < positions.length; i++) {
                //le coordinate provengono da una scena grande 10x10
                //trasforma le coordinate in modo che siano centrate e che la scena sia grande 1000x1000
                positions[i][0] = (positions[i][0] *70 )+ canvas.width/2;
                positions[i][2] = (positions[i][2] *70) + canvas.height/2;
            }

            //sposta in un altro array le coppie di coordinate diverse da (750, 750) tranne la prima
            //questo perchè la prima coppia di coordinate è (0,0) e non voglio che venga visualizzata
            let coordinates = [];
            let n = positions.length - 1;
            for (let i = 0; i <= n; i++) {
                coordinates.push(positions.pop());
                console.log(positions[i]);
            }

            console.log(coordinates);

            //l'array coordinates contiene vettori [x, y] che rappresentano le coordinate
            //disegna il percorso che l'oggetto ha fatto

            ctx.beginPath();

            //disegna un pallino color vinaccio per ogni coppia di coordinate
            //l'ultimo pallino è verde

            for (let i = 0; i < coordinates.length-2; i++) {
                ctx.moveTo(coordinates[i][0], coordinates[i][2]);
                ctx.lineTo(coordinates[i+1][0], coordinates[i+1][2]);
                ctx.strokeStyle = "red";
                ctx.lineWidth = 5;
                ctx.stroke();

                ctx.beginPath();
                ctx.arc(coordinates[i][0], coordinates[i][2], 10, 0, 2 * Math.PI);
                ctx.fillStyle = "purple";
                ctx.fill();
            }

            ctx.beginPath();
            ctx.arc(coordinates[coordinates.length - 2][0], coordinates[coordinates.length - 2][2], 20, 0, 2 * Math.PI);
            ctx.fillStyle = "blue";
            ctx.fill();

            //disegna un cerchio vuoto, circonferenza verde di raggio 110
            //fai console.log delle coordinate dei punti che sono dentro il cerchio
            //se la distanza tra il punto e il centro del cerchio è minore del raggio del cerchio allora il punto è dentro il cerchio
            //il centro del cerchio è l'ultima coppia di coordinate
            //il raggio del cerchio è 200
            let radius = 500;
            //leggi il valore del raggio da un input range
            radius = document.getElementById("radius").value;
            ctx.beginPath();
            ctx.arc(coordinates[coordinates.length - 1][0], coordinates[coordinates.length - 1][2], radius, 0, 2 * Math.PI);
            ctx.strokeStyle = "green";
            ctx.lineWidth = 5;
            ctx.stroke();



            for (let i = 0; i < coordinates.length; i++) {
                let distance = Math.sqrt(Math.pow(coordinates[i][0] - coordinates[coordinates.length - 1][0], 2) + Math.pow(coordinates[i][2] - coordinates[coordinates.length - 1][2], 2));
                if (distance < radius) {
                    console.log(coordinates[i]);
                }
            }

        }

        async function drawFacade(){
          await draw(p1_ctx,_positions, null, "red", "purple");
          await draw(p2_ctx,_positions_2, null,  "blue", "yellow");
        }

        async function drawFacadeWithFilters(){
          await draw(p1_ctx,_positions, null, "red", "purple");
          await draw(p2_ctx,_positions_2, null,  "blue", "yellow");
        }

        async function  draw(_ctx, positions, date_time, rail_color, point_color){
            //setta il background della canvas della dimensione della canvas
            //prendere informazioni, come width e height, dall'entità ngsi-ld Scene
            /*
             * Richiamare un endpoint del backend e non del broker
             * Recuperare le stesse informazioni
            */
            //const first = await fetch('https://broker.minerva.sferainnovazione.com/ngsi-ld/v1/entities/urn:ngsi-ld:Scene:002');
            //const data2 = await first.json();

            //setta width e height della canvas usando i dati del json moltiplicati per 70
            //canvas.width = data2.width.value * 70;
            //canvas.height = data2.length.value * 70;


            //ctx.drawImage(background,0,0, canvas.width, canvas.height);

            //prendi le coordinate dal json
            //nell'array position itera sugli oggetti e prendi l'array "value" questo contiene le coordinate
            //pusha le coordinate nell'array coordinates
            /*
            for (let i = 0; i < positions.length; i++) {
                //le coordinate provengono da una scena grande 10x10
                //trasforma le coordinate in modo che siano centrate e che la scena sia grande 1000x1000
                positions[i][0] = (positions[i][0] *70 )+ canvas.width/2;
                positions[i][2] = (positions[i][2] *70) + canvas.height/2;
                console.log(positions[i]);
            }
            */

            //sposta in un altro array le coppie di coordinate diverse da (750, 750) tranne la prima
            //questo perchè la prima coppia di coordinate è (0,0) e non voglio che venga visualizzata
            /*
            let coordinates = [];
            let n = positions.length - 1;
            for (let i = 0; i <= n; i++) {
                coordinates.push(positions.pop());
            }

            console.log(coordinates);
            */
            //l'array coordinates contiene vettori [x, y] che rappresentano le coordinate
            //disegna il percorso che l'oggetto ha fatto

            ctx.beginPath();

            //disegna un pallino color vinaccio per ogni coppia di coordinate
            //l'ultimo pallino è verde
            /*
            for (let i = 0; i < positions.length -1; i++) {
                let date = new Date(positions[i].timestamp);
                let date1 = new Date("2023-09-29T10:17:00.00Z");

                if(date > date1){
                  ctx.moveTo(positions[i].position[0], positions[i].position[2]);
                  ctx.lineTo(positions[i+1].position[0], positions[i+1].position[2]);
                  ctx.strokeStyle = "red";
                  ctx.lineWidth = 5;
                  ctx.stroke();

                  ctx.beginPath();
                  ctx.arc(positions[i].position[0], positions[i].position[2], 10, 0, 2 * Math.PI);
                  ctx.fillStyle = "purple";
                  ctx.fill();
                }

            }
            */
            //disegna la linea dalla posizione positions[positions.length - 2] alla posizione positions[positions.length - 1], cioè dall'ultima posizione alla penultima senza ridisegnare tutto il percorso
            /*
            console.log("POS", positions[positions.length - 2])

            console.log("TIMESTAMP", positions[positions.length - 2].timestamp)
            let date = document.getElementById("date").value;
            let time = document.getElementById("time").value;

            date_time = date + "T" + time + ":00.00Z";
            let _date = new Date(positions[positions.length - 2].timestamp);
            let _date_time = new Date(date_time);
            */
            //if(_date_time <= _date || date == '' || time == ''){
              _ctx.moveTo(positions[positions.length - 2].position[0], positions[positions.length - 2].position[2]);
              _ctx.lineTo(positions[positions.length - 1].position[0], positions[positions.length - 1].position[2]);
              _ctx.strokeStyle = rail_color;
              _ctx.lineWidth = 5;
              _ctx.stroke();


              _ctx.beginPath();
              _ctx.arc(positions[positions.length - 2].position[0], positions[positions.length - 2].position[2], 10, 0, 2 * Math.PI);
              _ctx.fillStyle = point_color;
              _ctx.fill();
            //}



            //disegna un cerchio vuoto, circonferenza verde di raggio 110
            //fai console.log delle coordinate dei punti che sono dentro il cerchio
            //se la distanza tra il punto e il centro del cerchio è minore del raggio del cerchio allora il punto è dentro il cerchio
            //il centro del cerchio è l'ultima coppia di coordinate
            //il raggio del cerchio è 200
            drawPercentegeCircle(positions);
        }

        function drawGreenCircle(pos){
          //disegna un cerchio pieno colore verde di raggio 50 usando data.position[0] e data.position[2]
          objs_ctx.clearRect(0, 0, objs_canvas.width, objs_canvas.height);

          objs_ctx.beginPath();
          objs_ctx.arc((pos[0] *70 )+ 700, (pos[2] *70 )+ 700, 50, 0, 2 * Math.PI);
          objs_ctx.fillStyle = "green";
          objs_ctx.fill();
        }

        //aggiunge un evento al click del mouse sulla canvas
        circles_canvas.addEventListener('click', function(event) {
            //prendi le coordinate del click del mouse e ruotale di 180 gradi
            let x = event.clientX;
            let y = event.clientY;
            console.log(x, y);
            //ruota le coordinate di 180 gradi
            x = canvas.width - x;
            y = canvas.height - y;

            center.x = x;
            center.y = y;

            drawPercentegeCircle(_positions);
          }, false);

        function drawPercentegeCircle(positions){
          circles_ctx.clearRect(0, 0, circles_canvas.width, circles_canvas.height);
          let radius = 500;

          //leggi il valore del raggio da un input range
          radius = document.getElementById("radius").value;
          circles_ctx.beginPath();
          circles_ctx.arc(center.x, center.y, radius, 0, 2 * Math.PI);
          circles_ctx.strokeStyle = "green";
          circles_ctx.lineWidth = 5;
          circles_ctx.stroke();


          //stampa la percentuale di punti che sono dentro il cerchio
          let count = 0;

          for (let i = 0; i < positions.length; i++) {
              let distance = Math.sqrt(Math.pow(positions[i].position[0] - center.x, 2) + Math.pow(positions[i].position[2] - center.y, 2));
              if (distance < radius) {
                  count++;
              }
          }

          document.getElementById("percent").innerHTML = Math.round((count/positions.length)*100) + "%";
        }
    </script>
</body>
</html>
