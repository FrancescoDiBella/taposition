<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link
      href="https://fonts.googleapis.com/css?family=Roboto:400,700"
      rel="stylesheet"
    />
    <title>Tracking</title>
    <style>
      body,
      html {
        background-color: #b9d0d3;
        font-family: "Roboto", sans-serif;
      }

      body {
        transform: scale(0.55); /* Applica uno zoom out del 75% */
        transform-origin: 0 0; /* Specifica il punto di origine per la trasformazione */
        max-width: 2500px;
        min-width: 1800px;
        max-height: 1800px;
        overflow-y: scroll;
      }
      canvas {
        rotate: 180deg;
        border: 1px solid red;
      }

      .container {
        display: flex;
        position: relative;
      }

      #canvas {
        position: relative;
      }

      .player-canvas {
      }

      .player-canvas-block {
        display: block;
        position: relative;
      }

      .sub-container {
        position: relative;
      }

      .secondary-canvas {
        position: absolute;
        background-color: transparent;
        top: 0;
        left: 0;
      }

      .table-cont {
        width: 100%;
        overflow: auto;
      }

      .content {
        padding: 20px;
        display: flex;
        flex-direction: column;
        justify-content: flex-start;
        align-items: flex-start;
        background-color: #f5f5f5;
        box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
        border-radius: 5px;
      }

      .input-group {
        margin-bottom: 20px;
      }

      .input-group label {
        font-size: 16px;
        display: block;
        margin-bottom: 5px;
      }

      input[type="range"],
      select,
      input[type="time"],
      input[type="date"] {
        font-size: 16px;
        width: 100%;
        padding: 10px;
        border: 1px solid #ccc;
        border-radius: 5px;
        background-color: #f9f9f9;
        margin-bottom: 10px;
      }

      button {
        background-color: #007bff;
        color: white;
        font-size: 16px;
        padding: 10px 20px;
        border: none;
        border-radius: 5px;
        cursor: pointer;
        transition: background-color 0.3s;
      }

      button:hover {
        background-color: #0056b3;
      }

      .big {
        font-size: 22px;
      }

      /* CSS per il bottone switch */
      .switch {
        position: relative;
        display: inline-block;
        width: 60px;
        height: 34px;
      }

      .switch input {
        opacity: 0;
        width: 0;
        height: 0;
      }

      .slider {
        position: absolute;
        cursor: pointer;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background-color: #ccc;
        -webkit-transition: 0.4s;
        transition: 0.4s;
        border-radius: 34px;
      }

      .slider:before {
        position: absolute;
        content: "";
        height: 26px;
        width: 26px;
        left: 4px;
        bottom: 4px;
        background-color: white;
        -webkit-transition: 0.4s;
        transition: 0.4s;
        border-radius: 50%;
      }

      input:checked + .slider {
        background-color: #007bff;
      }

      input:focus + .slider {
        box-shadow: 0 0 1px #007bff;
      }

      input:checked + .slider:before {
        -webkit-transform: translateX(26px);
        -ms-transform: translateX(26px);
        transform: translateX(26px);
      }

      /* Stile del bottone switch quando è "acceso" */
      .slider.round {
        border-radius: 34px;
      }

      .slider.round:before {
        border-radius: 50%;
      }

      #container-canvas {
        flex: 1;
        width: 1400px;
        height: 1400px;
      }
    </style>
  </head>
  <body>
    <div class="container" id="container">
      <div id="container-canvas"></div>
      <div class="content">
        <div class="input-group">
          <label for="radius"><b class="big">Raggio:</b></label>
          <input
            type="range"
            id="radius"
            min="0"
            max="800"
            value="200"
            class="big"
          />
        </div>

        <div class="input-group">
          <label for="percent" class="big"
            ><b class="big">Percentuale punti nell'area:</b></label
          >
          <span class="big" id="percent"></span>
        </div>

        <div class="input-group">
          <label for="player" class="big"><b class="big">Giocatore:</b></label>
          <select name="player" class="big" id="select-player">
          </select>
        </div>

        <div class="input-group">
          <label for="toggleFunction" class="big"
            ><b class="big">Visuale comparata:</b></label
          >
          <label class="switch">
            <input type="checkbox" id="toggleFunction" checked />
            <span class="slider round"></span>
          </label>
        </div>

        <div>_____________________________________</div>
        <!--
          <div class="input-group">
          <label for="time" class="big"><b class="big">Tempo:</b></label>
          <input type="time" id="time" class="big" />
        </div>

        <div class="input-group">
          <label for="date" class="big"><b class="big">Data:</b></label>
          <input type="date" id="date" class="big" />
        </div>
        -->


        <div class="input-group" id="sessions-group">
        </div>

        <button class="big" id="filter-btn">Filtra</button>
      </div>
    </div>

    <script
      type="text/javascript"
      src="//cdnjs.cloudflare.com/ajax/libs/core-js/2.1.4/core.min.js"
    ></script>
    <script
      crossorigin="anonymous"
      src="//unpkg.com/@feathersjs/client@^4.5.0/dist/feathers.js"
    ></script>
    <script
      crossorigin="anonymous"
      src="//unpkg.com/socket.io-client@^2.3.0/dist/socket.io.js"
    ></script>

    <script type="module">
      import { TrackingCanvas } from "./js/track-canvas.js";
      console.log(TrackingCanvas);
      // Socket.io is exposed as the `io` global.
      var socket = io("wss://wsminervabridge.sferainnovazione.com");
      // @feathersjs/client is exposed as the `feathers` global.
      var app = feathers();
      var _positions = new Array();
      var _positions_2 = new Array(); //array di posizioni del secondo player
      var playersPositions = {}; //array di array di posizioni di tutti i player
      var playersCanvas = {}; //array di array di canvas di tutti i player
      var idAdmin, idApp3D, idLms;
      var array_users = [];
      var sessions = [];

      const container = document.getElementById("container-canvas");
      //crea una canvas dentro il canvas-container per disegnare il cerchio verde
      const greenCircleCanvas = document.createElement("canvas");
      greenCircleCanvas.id = "green-circle-canvas";
      greenCircleCanvas.style.zIndex = 9999;
      greenCircleCanvas.width = 1400;
      greenCircleCanvas.height = 1400;
      greenCircleCanvas.classList.add('secondary-canvas');
      container.appendChild(greenCircleCanvas);


      //seleziona il player
      document.getElementById("select-player").addEventListener("change", function () {
        console.log("changed");
        let player = document.getElementById("select-player").value;

        if(player == "everyone"){
          array_users.forEach((user) => {
            document
            .getElementById("container-canvas-player-"+user).removeAttribute("hidden");
          });
          return;
        }else{
          array_users.forEach((user) => {
            if(user != player){
              document
              .getElementById("container-canvas-player-"+user).setAttribute("hidden", "hidden");
            }else{
              document
              .getElementById("container-canvas-player-"+user).removeAttribute("hidden");
            }
          });
        }
      });

      var center = { x: 0, y: 0 };

      app.configure(feathers.socketio(socket));
      const entitiesService = app.service("entity");

      socket.on("connect", () => console.log("Connected to server."));

      socket.on("test-ngsild created", async (data) => {
        try {
          if (data.type != undefined) {
            return;
          }
        } catch (e) {
          return;
        }

        let pos = data;
        //estrai la terza stringa dopo il secondo :
        //ad esempio: minerva:2:12396:ABCD:player2" -> 12396
        let idUsr = pos.id.split(":")[2];
        pos.position[0] = pos.position[0] * 70 + 700;
        pos.position[2] = pos.position[2] * 70 + 700;

        playersPositions[idUsr].push(pos);
        await draw(
          playersCanvas[idUsr].pointsCanvas,
          playersCanvas[idUsr].linesCanvas,
          playersPositions[idUsr],
          null,
          playersCanvas[idUsr].linesColor,
          playersCanvas[idUsr].pointsColor
        );
      });

      socket.on("test-ngsild obj-pos", async (data) => {
        //disegna un cerchio colore verde di raggio 50 usando data.position[0] e data.position[2]
        console.log("OBJ VERDE", data);
        //await drawGreenCircle(data.position);
      });

      function pushPos(pos) {
        _positions.push(pos);
      }

      function getLength() {
        return _positions.length;
      }

      async function drawFacade() {
        await draw(p1_ctx, _positions, null, "red", "purple");
        await draw(p2_ctx, _positions_2, null, "blue", "yellow");
      }


      async function drawFacadeWithFilters() {
        //usa la sessione selezionata per filtrare i dati e disegnare i punti
        //prendi la sessione selezionata
        //per ogni player prendi le posizioni della sessione selezionata
        array_users.forEach(async (user) => {
          let sessionId = document.getElementById("picker-session-"+user).value;
          //prendi dall'oggetto sessions la sessione con id sessionId
          //sessions è un array di oggetti data
          //ogni oggetto data ha un oggetto sessionId
          //ogni oggetto sessionId ha un campo value
          console.log(sessions)

          const session = sessions.reduce((acc, _session) => {
            const dataItem = _session.data.find(data => data.sessionId.value === sessionId);
            if (dataItem) {
              acc.push(dataItem);
            }
            return acc;
          }, [])[0];
          console.log(user, session);
          let data = await getPropertiesBySession(user, idApp3D, idLms, "position", session);
          console.log(data);
          //aggiorna i dati di playersPositions
          //richiama la funzione manipulateDataPositions
          //se data.data (che è un oggetto) non ha campi allora non ci sono dati da visualizzare
          if (Object.keys(data.data).length === 0) {
            console.log('L\'oggetto interno è vuoto.');
            //fai clear della canvas
            playersCanvas[user].pointsCanvas.clear();
            playersCanvas[user].linesCanvas.clear();

            return;
          }
          manipulateDataPositionsV2(
            user,
            data,
            playersCanvas[user].pointsColor,
            playersCanvas[user].linesColor,
            playersCanvas[user].pointsCanvas,
            playersCanvas[user].linesCanvas
          );
        });
      }

      function toggleVisual() {
        let _canvas = document.getElementsByClassName("player-canvas");

        Array.from(_canvas).forEach((canvas) => {
          canvas.classList.toggle("secondary-canvas");
          canvas.classList.toggle("player-canvas-block");
        });
      }

      async function draw(
        pointsCanvas,
        linesCanvas,
        positions,
        date_time,
        rail_color,
        point_color
      ) {
        console.log("draw", positions);
        const point1 = {
          x: positions[positions.length - 2].position[0],
          y: positions[positions.length - 2].position[2],
        };

        const point2 = {
          x: positions[positions.length - 1].position[0],
          y: positions[positions.length - 1].position[2],
        };

        pointsCanvas.drawPoints([point1, point2], {
          color: point_color,
          radius: 10,
        });
        linesCanvas.drawLines([point1, point2], {
          lineColor: rail_color,
          lineWidth: 4,
        });
      }

      async function drawAllPoints(
        pointsCanvas,
        linesCanvas,
        positions,
        rail_color,
        point_color
      ) {
        let points = [];

        positions.forEach((pos) => {
          points.push({ x: pos.position[0], y: pos.position[2] });
        });

        pointsCanvas.drawPoints(points, { color: point_color, radius: 10 });
        linesCanvas.drawLines(points, { lineColor: rail_color, lineWidth: 4 });

        //elimina l'array points
        points = [];
      }

      async function manipulateDataPositions(
        idUsr,
        data,
        pointsColor,
        linesColor,
        p1canvas,
        p1LinesCanvas
      ) {
        let pos = [];

        for (let i = 0; i < data.position.length; i++) {
          pos.push({ position: [] });
          pos[i].position[0] = data.position[i].value[0] * 70 + 700;
          pos[i].position[2] = data.position[i].value[2] * 70 + 700;
          playersPositions[idUsr].push(pos[i]);
        }
        await drawAllPoints(
          p1canvas,
          p1LinesCanvas,
          playersPositions[idUsr],
          linesColor,
          pointsColor
        );
      }

      async function manipulateDataPositionsV2(
        idUsr,
        data,
        pointsColor,
        linesColor,
        p1canvas,
        p1LinesCanvas
      ) {
        let pos = [];
        //clear playersPositions[idUsr]
        playersPositions[idUsr] = [];
        for (let i = 0; i < data.data.position.length; i++) {
          pos.push({ position: [] });
          pos[i].position[0] = data.data.position[i].value[0] * 70 + 700;
          pos[i].position[2] = data.data.position[i].value[2] * 70 + 700;
          playersPositions[idUsr].push(pos[i]);
        }
        //pulisci la canvas
        p1canvas.clear();
        p1LinesCanvas.clear();

        await drawAllPoints(
          p1canvas,
          p1LinesCanvas,
          playersPositions[idUsr],
          linesColor,
          pointsColor
        );
      }

      //quando la pagina è caricata
      window.onload = async function () {
        //carica i dati dal local storage
        let srt = localStorage.getItem("tracking");
        const tracking_list = JSON.parse(srt);
        console.log(tracking_list);
        idAdmin = tracking_list[0].idAdmin;
        idLms = tracking_list[0].idLms;
        idApp3D = tracking_list[0].idApp3D;

        let filterBtn = document.getElementById("filter-btn");
        filterBtn.addEventListener("click", drawFacadeWithFilters);

        //aggiungi un event listener allo slider
        let slider = document.getElementById("radius");

        // Funzione per ruotare le coordinate di 180 gradi
        function rotate180Degrees(x, y) {
            center.x = x * Math.cos(Math.PI) - y * Math.sin(Math.PI);
            center.y = x * Math.sin(Math.PI) + y * Math.cos(Math.PI);
        }


        slider.oninput = function () {
          //draw a green circle, get the radius from the slider and center from the center object
          let radius = document.getElementById("radius").value;
          let canvas = document.getElementById("green-circle-canvas");
          let ctx = canvas.getContext("2d");
          //clear the canvas
          ctx.clearRect(0, 0, canvas.width, canvas.height);
          ctx.beginPath();
          ctx.arc(center.x, center.y, radius, 0, 2 * Math.PI, false);
          ctx.lineWidth = 5;
          ctx.strokeStyle = "#003300";
          ctx.stroke();
        };

        slider.onchange = function () {
          //draw a green circle, get the radius from the slider and center from the center object
          let radius = document.getElementById("radius").value;
          let canvas = document.getElementById("green-circle-canvas");
          let ctx = canvas.getContext("2d");
          ctx.clearRect(0, 0, canvas.width, canvas.height);
          ctx.beginPath();
          ctx.arc(center.x, center.y, radius, 0, 2 * Math.PI, false);
          ctx.lineWidth = 5;
          ctx.strokeStyle = "#003300";
          ctx.stroke();
        };

        //aggiungi event listener al alla canvas, quando clicchi su un punto disegna un cerchio verde  centrato sul punto, deve aggiornare quindi l'oggetto center
        let canvas = document.getElementById("green-circle-canvas");
        canvas.addEventListener("click", function (e) {
          let rect = canvas.getBoundingClientRect();
          //ruota le coordinate di 180 gradi
          //converti da string a int
          let w = canvas.getAttribute("width");
          let h = canvas.getAttribute("height");

          //converti w e h in interi da stringhe
          w = parseInt(w);
          h = parseInt(h);

          let x = e.clientX - w;
          let y = e.clientY - h;
          rotate180Degrees(x, y);
          console.log(e.clientX, e.clientY, "canvas ->", w, h,"dopo -> ", x, y);

          let radius = document.getElementById("radius").value;
          let ctx = canvas.getContext("2d");
          ctx.clearRect(0, 0, canvas.width, canvas.height);
          ctx.beginPath();
          ctx.arc(center.x, center.y, radius, 0, 2 * Math.PI, false);
          ctx.lineWidth = 5;
          ctx.strokeStyle = "#003300";
          ctx.stroke();
        });

        let compare = document.getElementById("toggleFunction");
        compare.addEventListener("click", toggleVisual);

        tracking_list.forEach((track) => {
          array_users.push(track.idUsr);
        });

        //richiesta al broker
        //const sub_resp = await fetch('https://broker.minerva.sferainnovazione.com/ngsi-ld/v1/entities/urn:ngsi-ld:Scene:002');
        //ricreare la richiesta fatta sopra ma questa volta al bridge

        entitiesService
          .get(
            "minerva:" +
              idLms +
              ":" +
              array_users[0] +
              ":" +
              idApp3D +
              ":player"
          )
          .then((data) => {
            console.log(data);
            if (data.errorCode == 404) {
              alert("Non ci sono dati da visualizzare");
              return;
            }

            let sceneId = data.isContainedInObject.object;

            entitiesService
              .get(sceneId)
              .then((data) => {
                console.log(data);
                //setta width e height della canvas usando i dati del json moltiplicati per 70

                let width = data.width.value * 70;
                let height = data.length.value * 70;
                center.x = width / 2;
                center.y = height / 2;
                //fetchare i punti di tutti gli utenti nella userlist e visualizzarli con draw
                array_users.forEach((user) => {
                  //creare una nuova coppia di canvas per ogni utente
                  //aggiungere le due canvas al container
                  //crea un div con id "container-canvas-p-1"
                  const container_player = document.createElement("div");
                  container_player.id = "container-canvas-player-" + user;
                  container_player.classList.add("sub-container");

                  var pCanvas = new TrackingCanvas(
                    width,
                    height,
                    "player-" + user + "-canvas",
                    { zIndex: 4, classList: ["player-canvas"] }
                  );
                  var pLinesCanvas = new TrackingCanvas(
                    width,
                    height,
                    "player-" + user + "-lines-canvas",
                    { zIndex: 2, classList: [] }
                  );

                  pCanvas.render(container_player);
                  pLinesCanvas.render(container_player);

                  container.appendChild(container_player);
                  //passare le canvas e i colori a manipulateDataPositions
                  entitiesService
                    .get(
                      "minerva:" +
                        idLms +
                        ":" +
                        user +
                        ":" +
                        idApp3D +
                        ":player",
                      { query: { temporal: true } }
                    )
                    .then((data) => {
                      console.log(data);
                      playersPositions[user] = [];
                      //genera un colore random per i punti e per le linee che siano in contrasto
                      let pointsColor =
                        "#" + Math.floor(Math.random() * 16777215).toString(16);
                      let linesColor =
                        "#" + Math.floor(Math.random() * 16777215).toString(16);
                      playersCanvas[user] = {
                        pointsCanvas: pCanvas,
                        linesCanvas: pLinesCanvas,
                        pointsColor,
                        linesColor,
                      };

                      manipulateDataPositions(
                        user,
                        data,
                        pointsColor,
                        linesColor,
                        pCanvas,
                        pLinesCanvas
                      );
                    })
                    .catch((error) => {
                      console.log(error);
                    });
                });
              })
              .catch((error) => {
                console.log(error);
              });
          })
          .catch((error) => {
            console.log(error);
          });

        //aggiungi un select per ogni player per selezionare la sessione
        array_users.forEach(async (user) => {
          //Aggiungi una label con il nome dell'utente
          const label = document.createElement("label");
          label.for = "picker-session-" + user;
          const span = document.createElement("b");
          span.innerHTML = "Sessioni Player " + user+":";
          span.classList.add("big");
          const select = document.createElement("select");
          select.id = "picker-session-" + user;
          select.classList.add("big");
          document.getElementById("sessions-group").appendChild(label);
          label.appendChild(span);
          document.getElementById("sessions-group").appendChild(select);

          //aggiungi le sessioni al select
          //aggiungi 3 sessioni di prova
          //per ogni user prendi le sessioni e aggiungile al select
          //per ogni sessione aggiungi un option al select
          let tmpSessions = await getSessions(user, idApp3D, idLms);
          sessions.push(tmpSessions);
          for (let i = 0; i < tmpSessions.data.length; i++) {
            let option = document.createElement("option");
            option.value = tmpSessions.data[i].sessionId.value;
            option.text = "Session " + tmpSessions.data[i].sessionId.value;
            document.getElementById("picker-session-" + user).appendChild(option);
          }

        });

        //aggiungi al select i nomi degli utenti
        const selectPlayer = document.getElementById("select-player");
        array_users.forEach((user) => {
          let option = document.createElement("option");
          option.value = user;
          option.text = "Player " + user;
          selectPlayer.appendChild(option);
        });
        let option = document.createElement("option");
        option.value = "everyone";
        option.text = "Tutti";
        selectPlayer.appendChild(option);
        //setta come default l'opzione everyone
        selectPlayer.value = "everyone";
      };

      //funziona che fetcha i dati dal broker: /ngsi-ld/v1/entities?type=3DScene&q=hasObjects==minerva:2:12398:ABCD:player
      //e li restituisce
      async function getSessions(idUsr, idApp3D, idLms) {
        const resp = await fetch(
          "https://broker.minerva.sferainnovazione.com/ngsi-ld/v1/entities?type=3DScene&q=hasObjects==minerva:"+idLms+":"+idUsr+":"+idApp3D+":player"
        );
        const data = await resp.json();

        return {data};
      }

      //Queste funzioni vanno ancora testate
      async function getCurrentSession(idUsr, idApp3D, idLms) {
        const sessions = await getSessions(idUsr, idApp3D, idLms);
        console.log(sessions);
        //prendi la sessione corrente, essa è quella che non contiene il campo end
        let currentSession = sessions.data.filter((session) => {
          return session.end == undefined;
        });

        return currentSession;
      }

      async function getPropertyCurrentSession(idUsr, idApp3D, idLms, nameProperty) {
        const currentSession = await getCurrentSession(idUsr, idApp3D, idLms);
        const start = currentSession[0].start.value;
        //se end è undefined allora la sessione è quella corrente

        console.log(currentSession, start);
        //prendi le posizioni della sessione corrente
        const resp = await fetch(
          "https://broker.minerva.sferainnovazione.com/ngsi-ld/v1/temporal/entities/minerva:"+idLms+":"+idUsr+":"+idApp3D+":player?timeproperty=observedAt&timerel=after&timeAt="+start+"&attrs="+nameProperty
        );

        const data = await resp.json();
        console.log(data, "TUTTO OK")
        return {data};
      }

      async function getPropertiesBySession(idUsr, idApp3D, idLms, nameProperty, session) {
        console.log(session);
        const start = session.start.value;
        console.log(start);
        //ricontrollare il codice, non funziona ancora
        try{
          const end = session.end.value;
          console.log(start, end);
          //prendi i valori di property della sessione passata alla funzione
          const resp = await fetch(
            "https://broker.minerva.sferainnovazione.com/ngsi-ld/v1/temporal/entities/minerva:"+idLms+":"+idUsr+":"+idApp3D+":player?timeproperty=observedAt&timerel=between&timeAt="+start+"&endTimeAt="+end+"&attrs="+nameProperty
          );
          const data = await resp.json();
          console.log(data, "TUTTO OK");
          return {data};
        }catch(e){
          //se end è undefined allora la sessione è quella corrente
          console.log(e);
          return getPropertyCurrentSession(idUsr, idApp3D, idLms, nameProperty);
        }
      }

      //TODO: funzione che permette di animare il percorso di un player
      //praticamente prende le posizioni di un player e le disegna una alla volta
      //con un piccolo delay di mezzo secondo e/o regolabile


    </script>
  </body>
</html>
